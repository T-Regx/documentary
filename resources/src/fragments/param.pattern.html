<p>A delimited pattern to search for, with optional flags.</p>

Examples of delimited patterns with flags:
<ul>
  <li>`/^[a-z]+$/m` - matches: start of a line, one or more letters, end of line</li>
  <li>`#https?://(www\.)?\.[a-z]+\.[a-z]+#i` - matches: `http` or `https`, `://`, optional `www.`, one or more letters, `"."`
    character, one or more letters; all case-insensitive
  </li>
</ul>

Available flags:
<ul>
  <li>
    i (case insensitive) - If this modifier is set, letters in the pattern match both upper and lower case
    letters.

    For example:
    <ul>
      <li>`/[a-z]/i` is the same as `/[a-zA-Z]/`</li>
      <li>`/[A-Z]/i` is the same as `/[a-zA-Z]/`</li>
      <li>`/foo/i` is the same as `/[fF][oO][oO]/`</li>
    </ul>

    If this flag is used alongside flag `u`, accented letters will also match both upper and lower case letters.

    For example:
    <ul>
      <li>"/ó/ui" is the same as "/Ó/u"</li>
      <li>"/śźć/ui" is the same as "/ŚŹĆ/u"</li>
      <li>TODO: dopisac jeszcze \p{L}</li>
    </ul>
  </li>
  <li>m (multiline) - By default, PCRE treats the subject string as consisting of a single "line" of characters (even
    if it actually contains several newline characters (e.g. `"\n"` or `"\r"`). The "start of line" metacharacter
    (`^`) matches only at the start of the string, while the "end of line" metacharacter (`$`) matches only at the
    end of the string. This is the same as Perl.

    <p>When this modifier is set, the "start of line" and "end of line" constructs match immediately following or
      immediately before any newline in the subject string, respectively, as well as at the very start and end. </p>

    <p>In other words, if you consider a multiline string, `^` and `$` will normally match the start and the end of the
      whole string; but if `m` is used, `^` and `$` will match each line beginning and end.</p>

    <p>Notes:</p>
    <p>This is equivalent to Perl's `/m` modifier.</p>
    <p>If there are no `"\n"` characters in a subject string, or no occurrences of `^` or `$` in a
      pattern, setting this modifier has no effect.</p>
    <p>This flag disables `D` flag.</p>
  </li>
  <li>s (dot-all) - By default, newlines aren't matched by `"."` (`"."` is similar to `[^\n\r]`). If this modifier is
    set, a dot metacharacter in the pattern matches all characters, including newlines.
    <p>This modifier is equivalent to Perl's `/s` modifier.</p>
    <p>A negative class such as `[^a]` always matches a newline character, independent of the setting of this
      modifier.</p>
  </li>
  <li>x (extended) - If this modifier is set, whitespace data characters in the pattern are utterly ignored, except
    when escaped or inside a character class, and characters between an unescaped # outside a character class and
    the next newline character, inclusive, are also ignored. This is equivalent to Perl's /x modifier, and makes it
    possible to include commentary inside complicated patterns. Note, however, that this applies only to data
    characters. Whitespace characters may never appear within special character sequences in a pattern, for example
    within the sequence (?( which introduces a conditional subpattern.
  </li>
  <li>A (anchored) - If this modifier is set, the pattern is forced to be "anchored", that is, it is constrained to
    match only at the start of the string which is being searched (the "subject string"). This effect can also be
    achieved by appropriate constructs in the pattern itself (e.g. `"^"`), which is the only way to do it in Perl.
  </li>
  <li>D (dollar end-only) - By default, a dollar also matches a newline before the final character (but not before any
    other newlines), as if `$` was equal to `\n?$`.

    <p>If this modifier is set, a dollar metacharacter (`$`) in the pattern matches only at the end of the subject
      string (matching only the end of the string, without any newlines).</p>

    <p>Notes:</p>
    <p>This modifier is ignored, if `m` modifier is set.</p>
    <p>There is no equivalent to this modifier in Perl.</p>
  </li>
  <li>S (analyze) - When a pattern is going to be used several times, it is worth spending more time analyzing it in
    order to speed up the time taken for matching. If this modifier is set, then this extra analysis is performed.
    At present, studying a pattern is useful only for non-anchored patterns that do not have a single fixed starting
    character.
  </li>
  <li>U (ungreedy) - This modifier inverts the "greediness" of the quantifiers so that they are not greedy by default,
    but become greedy if followed by `?`. It is not compatible with Perl. It can also be set by a `(?U)` modifier
    setting within the pattern or by a question mark behind a quantifier (e.g. .*?).
    <p>Note:</p>
    It is usually not possible to match more than <b>pcre.backtrack_limit</b> characters in ungreedy mode.
  </li>
</ul>

<p>For a non-delimited pattern, use pattern() or Pattern::of().</p>